#Simulation And Estimation of GARCH(1,1)
--What are we talking about when we talk about fit?

This project aims to find out the reasoning for the estimation of GARCH model. 
First, we simulate a GARCH(1,1) process with arbitrary parameters. Then we illustrate how to fit the model with MLE and GMM.
Then we compare the parameters from the fitted result to the arbitraged one. Then we apply them to empircal data. 

##Simulate a GARCH process. 
Simulate a GARCH process.

$$
\sigma_t^2 = \omega+\alpha r_{t-1}^2+\beta \sigma^2_{t-1}\\
r_t = \sigma_t \epsilon_t \\
\epsilon_{t} \sim \mathcal{N}(0,1)\\
$$
We set the parameters as following: 
$$
\omega = 1\\
\alpha = 0.3\\
\beta = 0.5\\
\sigma_0 = \sqrt{\frac{1}{1-\alpha-\beta}}
$$

```{r}
omega <- 1
alpha <- 0.3
beta <- 0.5
sigma1 <- sqrt(1/(1-alpha-beta))
# N numbers of simulations
N <- 11000
```

Define our simulation function.

```{r}
simulate_garch <- function(omega,alpha,beta,sigma1,N){
  rs <- c(sigma1*rnorm(1))
  sigmas <- c(sigma1)
  for (i in 1:N-1) {
    #Simulate the epsilon
    epsilon <- rnorm(1)
    #Simulate the next r and put it in the bin.
    r <- sigmas[i]*epsilon
    rs <- c(rs,r)
    #Simulate the sigma
    sigma <- sqrt(omega+alpha*r**2+beta*sigmas[i]**2)
    sigmas <- c(sigmas,sigma)
  }
  simulation_result <- data.frame(
    index = c(1:N-1000),
    sigmas = sigmas,
    r = rs
  )
  simulation_result = tail(simulation_result,-1000)
  return(simulation_result)
}
simulation_result <- simulate_garch(omega,alpha,beta,sigma1,N)
write.csv(simulation_result,'simulation_result.csv')
library(ggplot2)
theme_set(theme_classic())
ggplot(data=simulation_result,aes(x=index, y=sigmas, group=1)) +
  geom_line(color="red")+
labs(title="GARCH(1,1) Simulation",
       caption="Source: Simulation",
       y="Sigma")
# ggplot2::ggsave("GARCH_simulations.jpg")
```
Next,we fit the model with rugarch packages as benchmark.
```{r}
library(rugarch)
garchSpec <- ugarchspec(
  variance.model=list(model="sGARCH", garchOrder=c(1,1)),
  mean.model=list(armaOrder = c(0,0),include.mean=F))
fit = ugarchfit(spec = garchSpec, data = simulation_result$r)
print(fit)
```
##Fit simulated data using MLE.
First, we derieve the likelihood of GARCH(1,1)
$$
r \sim \mathcal{N}(0,\sigma_t^2)\\
\theta = [\omega,\alpha,\beta]\\
f(r_0,r_1,\cdots ,r_t;\theta) = f(r_0;\theta)f(r_t|r_{t-1},\cdots, r_1;\theta)\\
=f(r_0;\theta)f(r_t|r_{t-1},\cdots, r_1;\theta)\\
=f(r_0;\theta)\Pi_{t=1}^{T} f(r_t|R_{t-1};\theta)\\
=f(r_0;\theta)\Pi_{t=1}^{T} \frac{1}{\sqrt{2\pi\sigma_t^2}}exp(-\frac{r_t^2}{2\sigma_t^2})\\
$$
Then we drop the first term $f(r_0;\theta)$ because it is a constant, and then take a log, then we have the log-likelihood function:
$$
\mathcal{L}(\theta) = \sum_{t=1}^{T} -\frac{1}{2} [ln(2\pi)+ln(\sigma_t^2) +\frac{r_t^2}{\sigma_t^2}]
$$
After we have the log-likelihood function, our objective would be find a vector $\hat\theta$ that can maximize $\mathcal{L(\theta)}$. 
$$
\hat\theta = \underset{\theta}{\operatorname{argmax}} \mathcal{L}(\theta) = \underset{\theta}{\operatorname{argmin}}-\mathcal{L}(\theta)
$$ 
Function to compute sigma squared. 
```{r}
compute_squared_sigmas <- function(rs,initial_sigma,theta){
  omega <- theta[1]
  alpha <- theta[2]
  beta <- theta[3]
  t  <- length(rs)
  sigma_squares <- c(initial_sigma**2)
  for (i in 2:t) {
    sigma_squares_i <- omega+alpha*rs[i-1]**2+beta*sigma_squares[i-1]
    sigma_squares <- c(sigma_squares,sigma_squares_i)
  }
  return(sigma_squares)
}


negative_log_likelihood_for_garch <- function(theta,rs=simulation_result$r){
  # rs <- simulation_result$r
  t <- length(rs)
  
  # Generate initial sigma squared
  initial_sigma <- sqrt(mean(rs**2))
  theta <- theta
  #Generate squared sigma values.
  sigma_squares <- compute_squared_sigmas(rs, initial_sigma, theta)
  #Compute likelihood for each t from 1 to T
  log_likelihoods <- c()
  for (i in 1:t) {
    log_likelihood <- -1/2*(log(2*pi)+log(sigma_squares[i]**2)+rs[i]**2/sigma_squares[i])
    log_likelihoods <- c(log_likelihoods,log_likelihood)
    # print(log_likelihood)
  }
  negative_log_likelihood <- sum(log_likelihoods)
  return(negative_log_likelihood)
}
# test compute squared sigmas
# mean(compute_squared_sigmas(simulation_result$r,2,c(1,0.3,0.5)))-mean(simulation_result$sigmas**2)
# Test log likelihoods.

```


Note that we also have three constraints:
$$
\alpha\ge0;\beta\ge0;\alpha+\beta<1
$$
Normally, we could take derivatives use KKT to tackle with this optimization problem. However, due to the recursive nature of GARCH models, it turns out to be very difficult to use these traditional optimization methods. 


This is done using slsqp in python using scipy optimize. 
The resutl we got is 
theta MLE: [1.00006464 0.29826454 0.50190327].

##Fit data with GMM
We use four moments for this GMM estimation.
$$
\hat{\epsilon} = \frac{1}{T}\sum_{t=1}^{T}\frac{r_t}{\sigma_t}\\
Var(\epsilon) = \frac{1}{T}\sum_{t=1}^{T}\epsilon_t^2 =\frac{1}{T}\sum_{t=1}^{T}(\frac{r_t}{\sigma_t})^2\\
Skew(\epsilon) = \frac{1}{T}\sum_{t=1}^{T}(\frac{r_t^3}{\sigma_t^3})\\
Kurtosis(\epsilon) = \frac{1}{T}\sum_{t=1}^{T}(\frac{r_t^4}{\sigma_t^4})\\
$$
Start with an identity matrix *W_0* and estimate a $\theta$ to minimize the object below:
$$
\min_{\theta \in \Theta} \left(\frac{1}{T} \sum_{t=1}^T g(r_t, \hat\theta)\right)' W_0 \left(\frac{1}{T}\sum_{t=1}^T g(r_t, \hat\theta)\right)
$$
Define the function to calculate the objective.
```{r}
gmm_objective_cal <- function(theta,W=diag(4),rs=simulation_result$r){
  #Initial Sigma 
  initial_sigma <- sqrt(mean(rs**2))
  # theta <- theta[1:3]
  #Calculate sigma_squares
  sigma_squares <- compute_squared_sigmas(rs,initial_sigma,theta)
  sigmas <- sqrt(sigma_squares)
  #Compute moments
  m1 <- mean(rs/sigmas)
  m2 <- mean(rs**2/sigma_squares)-1
  m3 <- mean(rs**3/sigmas**3)
  m4 <- mean((rs**4/sigma_squares**2)-3)
  #initialized g
  g <- c(m1,m2,m3,m4)
  # print(g)
  objective <- t(g) %*% W %*% g 
  # next_W <- g %*% t(g)
  # print(next_W)
  return(objective)
}
W <- diag(4)
objective <- gmm_objective_cal(c(1,0.3,0.5))
# objective
```

```{r}
gmm_cov <- function(theta,rs=simulation_result$r){
  initial_sigma <- sqrt(mean(rs**2))
  # theta <- theta[1:3]
  #Calculate sigma_squares
  sigma_squares <- compute_squared_sigmas(rs,initial_sigma,theta)
  sigmas <- sqrt(sigma_squares)
  #Compute moments
  m1 <- mean(rs/sigmas)
  m2 <- mean(rs**2/sigma_squares)-1
  m3 <- mean(rs**3/sigmas**3)
  m4 <- mean((rs**4/sigma_squares**2)-3)
  #initialized g
  g <- c(m1,m2,m3,m4)
  W <- g%*%t(g)
  return(W)
}
W <- gmm_cov(c(1,0.3,0.5))
W
```


```{r}
#Main Loops.
W = diag(4)
for(i in 1:3){
  objective_value <- gmm_objective_cal(c(1,0.3,0.5),W=W)
  print(objective_value)
  #Optimize
  result <- constrOptim(theta = c(1,0.1,0.3),f=gmm_objective_cal,grad = NULL,ui=rbind(c(0,1,0),c(0,0,1),c(0,-1,-1)),ci =c(0,0,-1))
  #Iterate
  g <- result$par
  print(g)
  W = gmm_cov(g)
}
```


---------------------------------------------------------
Appendix:
Convex Minimization Function








```{r}
result <- constrOptim(theta = c(1,0.1,0.3),f=gmm_objective_cal,grad = NULL,ui=rbind(c(0,1,0),c(0,0,1),c(0,-1,-1)),ci = c(0,0,-1))
result$par
```
























###Monte Carlo Minimum



```{r}

# generate_thetas <- function(n){
#   results <- matrix(nrow = 0, ncol = 3)
#   for (i in 1:n) {
#     theta <- c(1,runif(1),runif(1))
#     results <- rbind(results,theta)
#   }
#   return(results)
# }
# # Test function for mmc
# test_obj <- function(theta){
#   return(1-theta[2]-theta[3])
# }
# 
# for ( i in 100) {
#   results <- generate_thetas(100)
# 
# }
# 
# minimization_using_mc <- function(n){
#    thetas <- generate_thetas(n)
#    result <- test_obj(thetas[1,])
#    for (i in 2:n) {
#      theta <- thetas[i,]
#      #Find the minimum objective.
#      ## Test
#      # new_result <- test_obj(theta)
#      ## Find the minimum neg-loglikelihood
#      new_result <- negative_log_likelihood_for_garch(rs = simulation_result$r, theta)
#      if(new_result<result){
#        result <- new_result
#      }
#      # print(result)
#    }
#    return(theta) }
# # generate_thetas(100)[2,]
# theta <- minimization_using_mc(1000)
# theta
```






```{r}
theta <- c(1,2,3,4)
theta <- theta[1:3]
theta
```



















###Empircal Data
1. Read the data first. 
```{r}
gspc <- read.csv('GSPC.csv')
vix <- read.csv('VIX.csv')
#Only Use Close price
gspc <- data.frame(
  Date = as.Date.factor(gspc$Date),
  Price = gspc$Close
)
Date = as.Date.factor(gspc$Date)
vix <- data.frame(
  Date = as.Date.factor(vix$Date),
  Price = vix$Close
)
```





































